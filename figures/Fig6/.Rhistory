dfs <- lapply(1:3, function(x) {
o <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = x, row.names=T, startRow = 2)
o <- o[,grep('TRM|TexTerm',names(o))]
return(list(o[,1:9], o[,10:18]))
})
#
# df_tex <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = 1, row.names=T, startRow = 2)
# df_tex <- df_tex[,grep('TRM|TexTerm',names(df_tex))]
# df_tex_pr <- df_tex[,1:9]
# df_tex_rna <- df_tex[,10:18]
#
# df_trm <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = 2, row.names=T, startRow = 2)
# df_trm <- df_trm[,grep('TRM|TexTerm',names(df_trm))]
# df_trm_pr <- df_trm[,1:9]
# df_trm_rna <- df_trm[,10:18]
#
# df_both <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = 3, row.names=T, startRow = 2)
# df_both <- df_both[,grep('TRM|TexTerm',names(df_both))]
# df_both_pr <- df_both[,1:9]
# df_both_rna <- df_both[,10:18]
dfs[[1]]
## import data
dfs <- lapply(1:3, function(x) {
o <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = x, row.names=T, startRow = 2)
o <- o[,grep('TRM|TexTerm',names(o))]
return(list(o[,1:9], o[,10:18]))
})
gs <- lapply(dfs, function(x) bubble(rownames(x[1]), x[2], x[1]))
rownames(dfs[[1]][1])
rownames(dfs[[1]][[1]])
## import data
dfs <- lapply(1:3, function(x) {
o <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = x, row.names=T, startRow = 2)
o <- o[,grep('TRM|TexTerm',names(o))]
return(list(o[,1:9], o[,10:18]))
})
gs <- lapply(dfs, function(x) bubble(rownames(x[[1]]), x[[2]], x[[1]]))
#
# df_tex <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = 1, row.names=T, startRow = 2)
# df_tex <- df_tex[,grep('TRM|TexTerm',names(df_tex))]
# df_tex_pr <- df_tex[,1:9]
# df_tex_rna <- df_tex[,10:18]
#
# df_trm <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = 2, row.names=T, startRow = 2)
# df_trm <- df_trm[,grep('TRM|TexTerm',names(df_trm))]
# df_trm_pr <- df_trm[,1:9]
# df_trm_rna <- df_trm[,10:18]
#
# df_both <- read.xlsx("Extended Data Table 3 _ TF PageRank Scores of TRM and TEXterm TFs.xlsx", sheetIndex = 3, row.names=T, startRow = 2)
# df_both <- df_both[,grep('TRM|TexTerm',names(df_both))]
# df_both_pr <- df_both[,1:9]
# df_both_rna <- df_both[,10:18]
plot(gs[[1]])
View(bubble)
## get heatmap
p1 <- get_heatmap(df_multi)
## annotation file
group_sorted <- read.csv('group_file_for_heatmap.csv',header = T, row.names = 1)
mycolors <- list(subsets = c("#A6A6A6", "#FF0000", "#0007F4", "#FFA75C", "#00AAFE",
"#009051", "#FEB5B5", "#E6CFFF", "#8AAA75"))
names(mycolors$subsets) <- unique(group_sorted$Group)
breaksList = seq(-2, 2, by = 0.1)
# function
get_heatmap <- function(df,size=3,...){
g2 <- group_sorted[colnames(df),]
annotation_col = data.frame(subsets = g2$Group)
rownames(annotation_col) = colnames(df)
p1 <- pheatmap(df,
fontsize = size, angle_col = 90,
cellwidth = 2*size, cellheight = size,
cluster_cols = F,
annotation_col = annotation_col,
clustering_distance_cols = 'correlation',
clustering_distance_rows = 'correlation',
clustering_method = 'average',
# annotation_row = annotation_row,
breaks = breaksList,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
annotation_names_row = F, annotation_names_col = F,
annotation_colors = mycolors, border_color = NA,
filename = NA,...)
return(p1)
}
## get heatmap
p1 <- get_heatmap(df_multi)
?pheatmap
mycolors
names(mycolors$subsets)[1]
nrow(dfs[1])
nrow(dfs[[1]])
dfs[[1]]
dfs <- lapply(2:10, function(x) read.xlsx("Extended Data Table 1 _ TF PageRank Scores of non-specific versus specific TFs.xlsx", sheetIndex = x, row.names=T))
ps <- lapply(1:9, function(x) {
annotation_row <- data.frame("subsets"=rep(names(mycolors$subsets)[x],length(TFs)))
rownames(annotation_row) <- rownames(x)
get_heatmap(df=dfs[x], cluster_rows=F, annotation_row=annotation_row)
})
nrow(dfs[1])
nrow(dfs[[1]])
dfs <- lapply(2:10, function(x) read.xlsx("Extended Data Table 1 _ TF PageRank Scores of non-specific versus specific TFs.xlsx", sheetIndex = x, row.names=T))
ps <- lapply(1:9, function(x) {
annotation_row <- data.frame("subsets"=rep(names(mycolors$subsets)[x],nrow(dfs[[x]])))
rownames(annotation_row) <- rownames(dfs[[x]])
get_heatmap(df=dfs[[x]], cluster_rows=F, annotation_row=annotation_row)
})
df <- read.xlsx("Extended Data Table 1 _ TF PageRank Scores of non-specific versus specific TFs.xlsx", sheetIndex = 1, row.names=T)
get_heatmap(df, cluster_rows=F)
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(igraph))
suppressMessages(library(ggplot2))
suppressMessages(library(dplyr))
suppressMessages(library(RColorBrewer))
set.seed(42)
fl.sources <- list.files("../../scripts/utils/", full.names = T)
tmp <- sapply(fl.sources,source)
setwd('../Fig6/')
# extract edge info: take mean if edge exists in both networks
ge1 <- as_data_frame(g1) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
head(g1)
g1 <- readRDS('graph_shrinkage_res0.9_s0.15_TexTerm_subset_TFs_v2.rds')
g2 <- readRDS('graph_shrinkage_res0.9_s0.15_TRM_subset_TFs_v2.rds')
gv1 <- as_data_frame(g1, "vertices")
gv2 <- as_data_frame(g2, "vertices")
common_tfs <- intersect(gv1$name, gv2$name)
tex_tfs <- setdiff(gv1$name, gv2$name)
trm_tfs <- setdiff(gv2$name, gv1$name)
# extract edge info: take mean if edge exists in both networks
ge1 <- as_data_frame(g1) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
ge2 <- as_data_frame(g2) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
ge <- ge1 %>% full_join(ge2, by = c('from','to')) %>%
mutate(corr=ifelse(is.na(corr.x), corr.y, ifelse(is.na(corr.y), corr.x, (corr.x+corr.y)/2)),
edge.color=ifelse(is.na(corr.x), '#009051', ifelse(is.na(corr.y), '#8AAA75', '#808080')),
type=ifelse(is.na(corr.x), 'trm', ifelse(is.na(corr.y), 'tex', 'common'))) |>
select(from,to,corr,edge.color,type) |> na.omit()
ge
# extract edge info: take mean if edge exists in both networks
ge1 <- as_data_frame(g1) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
ge2 <- as_data_frame(g2) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
ge <- ge1 %>% full_join(ge2, by = c('from','to')) %>%
mutate(corr=ifelse(is.na(corr.x), corr.y, ifelse(is.na(corr.y), corr.x, (corr.x+corr.y)/2)),
edge.color=ifelse(is.na(corr.x), '#009051', ifelse(is.na(corr.y), '#8AAA75', '#808080')),
type=ifelse(is.na(corr.x), 'trm', ifelse(is.na(corr.y), 'tex', 'common'))) |>
select(from,to,corr,edge.color,type) |> na.omit()
knitr::kable(head(ge))
# extract edge info: take mean if edge exists in both networks
ge1 <- as_data_frame(g1) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
ge2 <- as_data_frame(g2) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to))
ge <- ge1 %>% full_join(ge2, by = c('from','to')) %>%
mutate(corr=ifelse(is.na(corr.x), corr.y, ifelse(is.na(corr.y), corr.x, (corr.x+corr.y)/2)),
edge.color=ifelse(is.na(corr.x), '#009051', ifelse(is.na(corr.y), '#8AAA75', '#808080')),
type=ifelse(is.na(corr.x), 'trm', ifelse(is.na(corr.y), 'tex', 'common'))) |>
select(from,to,corr,edge.color,type) |> na.omit()
knitr::kable(head(ge), caption = 'edge meta') |> kableExtra::kable_styling(latex_options = 'scale_down')
# create combined network from the edge meta
g <- graph_from_data_frame(ge, directed = FALSE, vertices = attrs)
as_data_frame(g1)
as_data_frame(g1, 'vertices')
gv1 <- as_data_frame(g1, "vertices") %>% select(name, cluster)
gv2 <- as_data_frame(g2, "vertices") %>% mutate(cluster2=ifelse(cluster==1, 3, ifelse(cluster==3, 1, cluster)))%>% select(name, cluster2)
attrs2 <- gv1 %>% full_join(gv2, by=c('name')) %>%
mutate(group=ifelse(name %in% common_tfs, 'Common', ifelse(name %in% tex_tfs, 'Tex', 'Trm')),
# color=ifelse(name %in% common_tfs, '#A020F0', ifelse(name %in% tex_tfs, '#7F6000', '#009051')),
color=ifelse(name %in% common_tfs, '#C0C0C0', ifelse(name %in% tex_tfs, '#BB8666', '#98D7AD')),
cluster_c=ifelse(is.na(cluster),cluster2,ifelse(is.na(cluster2), cluster,ifelse(cluster==cluster2, cluster, 'mixed'))))
attrs2
gv1 <- as_data_frame(g1, "vertices") %>% select(name, cluster)
gv2 <- as_data_frame(g2, "vertices") %>% mutate(cluster2=ifelse(cluster==1, 3, ifelse(cluster==3, 1, cluster)))%>% select(name, cluster2)
attrs2 <- gv1 %>% full_join(gv2, by=c('name')) %>%
mutate(group=ifelse(name %in% common_tfs, 'Common', ifelse(name %in% tex_tfs, 'Tex', 'Trm')),
color=ifelse(name %in% common_tfs, '#C0C0C0', ifelse(name %in% tex_tfs, '#BB8666', '#98D7AD')),
cluster_c=ifelse(is.na(cluster),cluster2,ifelse(is.na(cluster2), cluster,ifelse(cluster==cluster2, cluster, 'mixed'))))
knitr::kable(head(attrs2), caption = 'edge meta') |> kableExtra::kable_styling(latex_options = 'scale_down')
# create combined network from the edge meta
g <- graph_from_data_frame(ge, directed = FALSE, vertices = attrs2)
print(g, e=TRUE, v=TRUE)
G_Grouped = g
E(G_Grouped)$weight = 1
## Add edges with high weight between all nodes in the same group
for(i in unique(V(g)$cluster_c)) {
GroupV = which(V(g)$cluster_c == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.8))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
# function to generate network
get_figure <- function(x,ge,cut_off=0.8,label=F){
g <- graph_from_data_frame(ge, directed = FALSE, vertices = attrs2)
G_Grouped = g
E(G_Grouped)$weight = 1
## Add edges with high weight between all nodes in the same group
for(i in unique(V(g)$cluster_c)) {
GroupV = which(V(g)$cluster_c == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.8))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
# get degree
ge2 <- ge |> dplyr::filter(type==x)
g2 <- graph_from_data_frame(ge2, directed = FALSE, vertices = attrs2) # to get customized node size in each context
# generate label for all nodes
V(g)$frame.color <- 'gray'
V(g)$label <- NA
if (label){V(g)$label <- V(g)$name}
V(g)$label.color <- 'black'
V(g)$size <- 0.2*degree(g2) # degree in each context
# V(g)$label.cex <- 0.75 # part label
V(g)$label.cex <- 0.5 # all label
# set distance of label
V(g)$label.dist <- 0.4
# set edge color
# E(g)$color <- "gray80"
E(g)$color <- ifelse(E(g)$type=='common', '#C0C0C0', ifelse(E(g)$type=='trm', '#009051', '#945200'))
E(g)$size <- 0.1
E(g)$width <- 2*E(g)$corr
E(g)$lty <- ifelse((E(g)$corr>=unname(quantile(E(g)$corr, cut_off))) & (E(g)$type==x), 1, 0)
file = ifelse(label,paste0("merged_graph_v2_top",(1-cut_off),"_",x,"_labeled.pdf"),paste0("merged_graph_v2_top",(1-cut_off),"_",x,".pdf"))
pdf(file, width = 8, height = 8)
plot(g, layout=LO)
dev.off()
}
tmps <- lapply(c('common','trm','tex'), function(x) get_figure(x=x, ge=ge, cut_off=0.8,label=T))
# function to generate network
get_figure <- function(x,ge,cut_off=0.8,label=F){
g <- graph_from_data_frame(ge, directed = FALSE, vertices = attrs2)
G_Grouped = g
E(G_Grouped)$weight = 1
## Add edges with high weight between all nodes in the same group
for(i in unique(V(g)$cluster_c)) {
GroupV = which(V(g)$cluster_c == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.8))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
# get degree
ge2 <- ge |> dplyr::filter(type==x)
g2 <- graph_from_data_frame(ge2, directed = FALSE, vertices = attrs2) # to get customized node size in each context
# generate label for all nodes
V(g)$frame.color <- 'gray'
V(g)$label <- NA
if (label){V(g)$label <- V(g)$name}
V(g)$label.color <- 'black'
V(g)$size <- 0.2*degree(g2) # degree in each context
# V(g)$label.cex <- 0.75 # part label
V(g)$label.cex <- 0.5 # all label
# set distance of label
V(g)$label.dist <- 0.4
# set edge color
# E(g)$color <- "gray80"
E(g)$color <- ifelse(E(g)$type=='common', '#C0C0C0', ifelse(E(g)$type=='trm', '#009051', '#945200'))
E(g)$size <- 0.1
E(g)$width <- 2*E(g)$corr
E(g)$lty <- ifelse((E(g)$corr>=unname(quantile(E(g)$corr, cut_off))) & (E(g)$type==x), 1, 0)
# file = ifelse(label,paste0("merged_graph_v2_top",(1-cut_off),"_",x,"_labeled.pdf"),paste0("merged_graph_v2_top",(1-cut_off),"_",x,".pdf"))
# pdf(file, width = 8, height = 8)
plot(g, layout=LO)
# dev.off()
}
tmps <- lapply(c('common','trm','tex'), function(x) get_figure(x=x, ge=ge, cut_off=0.8,label=T))
# function to generate network
get_figure <- function(x,ge,cut_off=0.8,label=F){
g <- graph_from_data_frame(ge, directed = FALSE, vertices = attrs2)
G_Grouped = g
E(G_Grouped)$weight = 1
## Add edges with high weight between all nodes in the same group
for(i in unique(V(g)$cluster_c)) {
GroupV = which(V(g)$cluster_c == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.8))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
# get degree
ge2 <- ge |> dplyr::filter(type==x)
g2 <- graph_from_data_frame(ge2, directed = FALSE, vertices = attrs2) # to get customized node size in each context
# generate label for all nodes
V(g)$frame.color <- 'gray'
V(g)$label <- NA
if (label){V(g)$label <- V(g)$name}
V(g)$label.color <- 'black'
V(g)$size <- 0.2*degree(g2) # degree in each context
# V(g)$label.cex <- 0.75 # part label
V(g)$label.cex <- 0.5 # all label
# set distance of label
V(g)$label.dist <- 0.4
# set edge color
# E(g)$color <- "gray80"
E(g)$color <- ifelse(E(g)$type=='common', '#C0C0C0', ifelse(E(g)$type=='trm', '#009051', '#945200'))
E(g)$size <- 0.1
E(g)$width <- 2*E(g)$corr
E(g)$lty <- ifelse((E(g)$corr>=unname(quantile(E(g)$corr, cut_off))) & (E(g)$type==x), 1, 0)
# file = ifelse(label,paste0("merged_graph_v2_top",(1-cut_off),"_",x,"_labeled.pdf"),paste0("merged_graph_v2_top",(1-cut_off),"_",x,".pdf"))
# pdf(file, width = 8, height = 8)
print(paste0('network for ', x))
plot(g, layout=LO)
# dev.off()
}
tmps <- lapply(c('common','trm','tex'), function(x) get_figure(x=x, ge=ge, cut_off=0.8,label=T))
?plot
??igraph::plt
??igraph::plot
G_Grouped = g
E(G_Grouped)$weight = 1
## Add edges with high weight between all nodes in the same group
for(i in unique(V(g)$cluster_c)) {
GroupV = which(V(g)$cluster_c == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.8))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
# function to generate network
get_figure <- function(x,ge,cut_off=0.8,label=F){
g <- graph_from_data_frame(ge, directed = FALSE, vertices = attrs2)
G_Grouped = g
E(G_Grouped)$weight = 1
## Add edges with high weight between all nodes in the same group
for(i in unique(V(g)$cluster_c)) {
GroupV = which(V(g)$cluster_c == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.8))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
# get degree
ge2 <- ge |> dplyr::filter(type==x)
g2 <- graph_from_data_frame(ge2, directed = FALSE, vertices = attrs2) # to get customized node size in each context
# generate label for all nodes
V(g)$frame.color <- 'gray'
V(g)$label <- NA
if (label){V(g)$label <- V(g)$name}
V(g)$label.color <- 'black'
V(g)$size <- 0.2*degree(g2) # degree in each context
# V(g)$label.cex <- 0.75 # part label
V(g)$label.cex <- 0.5 # all label
# set distance of label
V(g)$label.dist <- 0.4
# set edge color
# E(g)$color <- "gray80"
E(g)$color <- ifelse(E(g)$type=='common', '#C0C0C0', ifelse(E(g)$type=='trm', '#009051', '#945200'))
E(g)$size <- 0.1
E(g)$width <- 2*E(g)$corr
E(g)$lty <- ifelse((E(g)$corr>=unname(quantile(E(g)$corr, cut_off))) & (E(g)$type==x), 1, 0)
# file = ifelse(label,paste0("merged_graph_v2_top",(1-cut_off),"_",x,"_labeled.pdf"),paste0("merged_graph_v2_top",(1-cut_off),"_",x,".pdf"))
# pdf(file, width = 8, height = 8)
plot(g, layout=LO, main = paste0(x, ' network'))
# dev.off()
}
tmps <- lapply(c('common','trm','tex'), function(x) get_figure(x=x, ge=ge, cut_off=0.8,label=T))
tmps <- lapply(c('common','trm','tex'), function(x) get_figure(x=x, ge=ge, cut_off=0.8,label=T))
common_tfs
trm_tfs
# define function
get_graph <- function(id){
ge1 <- as_data_frame(g1) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to)) %>% mutate(edge.color='#7F6000')
ge2 <- as_data_frame(g2) %>% select(from, to, corr) %>% transform(from=pmin(from, to), to=pmax(from,to)) %>% mutate(edge.color='#009051')
ge <- rbind(ge1,ge2)
ge3 <- ge %>% filter(from == id | to == id)
nodes <- union(ge3$from, ge3$to)
attrs3 = data.frame('name'=nodes) %>% mutate(color=ifelse(name %in% common_tfs, '#C0C0C0', ifelse(name %in% tex_tfs, '#7F6000', '#009051')))
g <- graph_from_data_frame(ge3, directed = FALSE, vertices = attrs3)
V(g)$label.color <- 'black'
# V(g)$size <- 10*degree(g)
V(g)$size <- ifelse(V(g)$name == id, 12, 7)
# V(g)$label.cex <- 0.75 # part label
V(g)$label.cex <- 1 # all label
# set distance of label
V(g)$label.dist <- 1
# set edge color
# E(g)$color <- "gray80"
E(g)$color <- ge3$edge.color
E(g)$size <- 1
E(g)$width <- 3*E(g)$corr
G_Grouped = g
E(G_Grouped)$weight = 1
## make edges of the same type close to each other in the layout
for(i in unique(V(g)$color)) {
GroupV = which(V(g)$color == i)
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=0.1))
}
## Now create a layout based on G_Grouped
set.seed(567)
LO = layout_with_fr(G_Grouped)
set.seed(1)
plot(g, layout=LO, main = paste0(id, ' network'))
}
# visualize some example TFs
lapply(c('Hic1','Fosb','Zfp324'), get_graph)
# visualize some example TFs
tmp <- lapply(c('Hic1','Fosb','Zfp324'), get_graph)
# visualize some example TFs
tmp <- lapply(c('Hic1','Fosb','Zfp324'), get_graph)
knitr::opts_chunk$set(echo = TRUE)
# prepare edge info
df <- read.csv('Hic1_Prdm1_RegulationFlipping_figure_input_20240529-lc.csv')[,c(1:4)] |> na.omit() |> mutate(pair=paste0(regulator,'-',regulatee)) |> dplyr::select(pair, TexTerm, TRM) |> tibble::column_to_rownames('pair')
df <- df |> tibble::rownames_to_column('pair') |> tidyr::separate('pair',into = c('from','to'),sep = '-') |>
tidyr::pivot_longer(!c('from','to'),names_to='group', values_to = 'corr') |>
# mutate(edge.color=ifelse(group=='TexTerm','#7F6000','#009051'), edge.lty=ifelse(corr<0, 1, 2), abs.corr=abs(corr)) |>
mutate(edge.color=ifelse(corr<0, '#C00000', '#0070C0'), abs.corr=abs(corr)) |>
filter(corr!=0)
# prepare edge info
df <- read.csv('Hic1_Prdm1_RegulationFlipping_figure_input_20240529-lc.csv')[,c(1:4)] |> na.omit() |> mutate(pair=paste0(regulator,'-',regulatee)) |> dplyr::select(pair, TexTerm, TRM) |> tibble::column_to_rownames('pair')
df <- df |> tibble::rownames_to_column('pair') |> tidyr::separate('pair',into = c('from','to'),sep = '-') |>
tidyr::pivot_longer(!c('from','to'),names_to='group', values_to = 'corr') |>
# mutate(edge.color=ifelse(group=='TexTerm','#7F6000','#009051'), edge.lty=ifelse(corr<0, 1, 2), abs.corr=abs(corr)) |>
mutate(edge.color=ifelse(corr<0, '#C00000', '#0070C0'), abs.corr=abs(corr)) |>
filter(corr!=0)
knitr::kable(head(df), caption = 'edge meta') |> kableExtra::kable_styling(latex_options = 'scale_down')
# set node color
nodes <- read.csv('node_color_20240529.csv')
tex_nodes <- nodes |> filter(color=='#B2876B') |> pull(node) |> unique()
trm_nodes <- nodes |> filter(color=='#A5D4AF') |> pull(node) |> unique()
?igraph::plot
??igraph::plot
# generate graph
tmp <- lapply(c('Hic1','Prdm1'), get_TF_regulatee_graph)
# define function
get_TF_regulatee_graph <- function(id){
ge <- df |> filter(from==id)
g <- graph_from_data_frame(ge, directed = FALSE)
edge.width.max <- 10
upper.limit <- 50
lower.limit <- 5
max_corr <- max(E(g)$abs.corr)
min_corr <- min(E(g)$abs.corr)
valuesq <- lapply(V(g)$name, function(x) ifelse(x %in% tex_nodes, return(c(0,1)), ifelse(x %in% trm_nodes, return(c(1,0)), return(c(1,1)))))
V(g)$size <- ifelse(V(g)$name == id, 20, 15)
V(g)$pie.color = list(c('#A5D4AF','#B2876B')) # first is TRM, second is TEX
V(g)$frame.color = ifelse(V(g)$name %in% tex_nodes, '#B2876B', '#A5D4AF')
V(g)[which(V(g)$name==id)]$pie.color = list(c('#808080','#808080'))
V(g)[which(V(g)$name==id)]$frame.color = '#808080'
E(g)$color <- ge$edge.color
# E(g)$width <- 0.5*E(g)$corr
E(g)$width <- 0.1*ifelse(E(g)$abs.corr>=upper.limit, upper.limit, ifelse(E(g)$abs.corr<=lower.limit,lower.limit,E(g)$abs.corr))
set.seed(1)
plot(g, arrow.mode=0, vertex.shape='pie',vertex.label.color='black', vertex.label.cex=1, vertex.pie=valuesq,curved=T)
}
# generate graph
tmp <- lapply(c('Hic1','Prdm1'), get_TF_regulatee_graph)
# generate graph
tmp <- lapply(c('Hic1','Prdm1'), get_TF_regulatee_graph)
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(pheatmap))
suppressMessages(library(dplyr))
suppressMessages(library(RColorBrewer))
df_fc <- read.csv('log2FC_btw_TEX_and_TRM_mean_edge_weight_subset_TFs_v2_top500_genes.csv', row.names = 1)
df_fc = df_fc[apply(df_fc,MARGIN = 1, FUN = function(x) length(unique(x)) > 1),apply(df_fc,MARGIN = 2, FUN = function(x) length(unique(x)) > 1)] # filter out rows and columns with all zeros
knitr::kable(head(df_fc), caption = 'log2 fold change of edge weight betweeen TEXterm and TRM') |> kableExtra::kable_styling(latex_options = 'scale_down')
set.seed(123)
k = 16
kmeans_model <- kmeans(df_fc, centers = k)
print(kmeans_model)
set.seed(123)
k = 16
kmeans_model <- kmeans(df_fc, centers = k)
p <- pheatmap::pheatmap(kmeans_model$centers,fontsize=5, cellheight=5, cellwidth=5,
show_colnames = T, show_rownames = T,
border_color = NA,
cluster_cols = T,
#               annotation_col = annotation_col,
annotation_colors = mycolors,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "BrBG")))(20))
p <- pheatmap::pheatmap(kmeans_model$centers,fontsize=5, cellheight=5, cellwidth=5,
show_colnames = T, show_rownames = T,
border_color = NA,
cluster_cols = T,
#               annotation_col = annotation_col,
annotation_colors = mycolors,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "BrBG")))(20))
p <- pheatmap::pheatmap(kmeans_model$centers,fontsize=5, cellheight=5, cellwidth=5,
show_colnames = T, show_rownames = T,
border_color = NA,
cluster_cols = T,
#               annotation_col = annotation_col,
annotation_colors = mycolors,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "BrBG")))(20))
p <- pheatmap::pheatmap(kmeans_model$centers,fontsize=5, cellheight=5, cellwidth=5,
show_colnames = T, show_rownames = T,
border_color = NA,
cluster_cols = T,
#               annotation_col = annotation_col,
annotation_colors = mycolors,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "BrBG")))(20))
p <- pheatmap::pheatmap(kmeans_model$centers,fontsize=5, cellheight=5, cellwidth=5,
show_colnames = T, show_rownames = T,
border_color = NA,
cluster_cols = T,
#               annotation_col = annotation_col,
annotation_colors = mycolors,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "BrBG")))(20))
p <- pheatmap::pheatmap(kmeans_model$centers,fontsize=5, cellheight=5, cellwidth=5,
show_colnames = T, show_rownames = T,
border_color = NA,
cluster_cols = T,
#               annotation_col = annotation_col,
annotation_colors = mycolors,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "BrBG")))(20))
source("../../scripts/utils/enrich_all.R")
output = as.data.frame(kmeans_model$cluster) %>% tibble::rownames_to_column('gene')
names(output) = c('gene','kmeans_cluster')
# # save to file
# write.csv(output, 'kmeans_cluster_k_16_log2FC_btw_TEX_and_TRM_mean_edge_weight_top500_subset_TFs_v2_v2_ordered_by_group.csv')
View(output)
View(enrich_all)
is.na(NULL)
is.null(NULL)
source("../../scripts/utils/enrich_all.R")
unique(output$kmeans_cluster)
unique(output$kmeans_cluster) |> length()
output |> dplyr::filter(kmeans_cluster==1) |> pull(gene)
