---
title: "visualization of TF activity"
author: "Cong"
date: "2024-09-07"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# import packages and functions

```{r import packages and functions}
suppressMessages(library(data.table))
suppressMessages(library(ggplot2))
suppressMessages(library(dplyr))
# suppressMessages(library(xlsx))
suppressMessages(library(pheatmap))
suppressMessages(library(RColorBrewer))


set.seed(42)
fl.sources <- list.files("../../scripts/utils/", full.names = T)
tmp <- sapply(fl.sources,source)
```

# set up plot parameters

```{r plot set-up}
## annotation file
group_sorted <- read.csv('group_file_for_heatmap.csv',header = T, row.names = 1)
mycolors <- list(subsets = c("#A6A6A6", "#FF0000", "#0007F4", "#FFA75C", "#00AAFE", 
                             "#009051", "#FEB5B5", "#E6CFFF", "#8AAA75"))
names(mycolors$subsets) <- unique(group_sorted$Group)
breaksList = seq(-2, 2, by = 0.1)

# function
get_heatmap <- function(df,size=3,...){
  g2 <- group_sorted[colnames(df),]
  annotation_col = data.frame(subsets = g2$Group) 
  rownames(annotation_col) = colnames(df)
  p1 <- pheatmap(df, 
                 fontsize = size, angle_col = 90, 
                 cellwidth = 2*size, cellheight = size,
                 cluster_cols = F, 
                 annotation_col = annotation_col,
                 clustering_distance_cols = 'correlation', 
                 clustering_distance_rows = 'correlation', 
                 clustering_method = 'average',
                 # annotation_row = annotation_row,
                 breaks = breaksList,
                 color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
                 annotation_names_row = F, annotation_names_col = F,
                 annotation_colors = mycolors, border_color = NA, ...)
  return(p1)
}

```

# import pagerank scores

```{r}
Data <- read.csv('pr_original.csv', row.names = 1)#### default scale
#### zscore
Data_normed <- zscore(Data)

#### scale to [0,1]
Data_normed_2 <- scaleData(Data)

#### scale to [-2,2]
tmp <- apply(Data_normed,1:2, function(x) min(x, 2))
Data_normed_3 <- as.data.frame(apply(tmp,1:2, function(x) max(x, -2)))

```

# identify non-specific TFs

Non-specific TFs are those TFs with mean PageRank ranked as top10% across 9 cell states and coefficients of variation (CV) less than 0.5

```{r}
tmp <- mostConserveTFs(highlyRankedTFs(Data,0.1),0.5) 
housekeeping <- rownames(tmp)
writeLines(housekeeping, 'housekeeping_top01_CV05.txt')
```

## heatmap of non-specific TFs

```{r, fig.width=10, fig.height=8}
get_heatmap(Data_normed_3[housekeeping,], cluster_rows=F, size = 5) 
```

# identify cell state-specific TFs

First we divided the samples into two groups: target group and background group. Target group included all the samples belonging to the cell state of interest and the background group comprised the remaining samples. Unpaired t-test was used to calculate the P-value. A P-value cutoff of 0.05 and log2 fold change cutoff of 0.5 were used for calling cell state-specific TFs.

```{r}
# load meta file
group_sorted <- read.table('group_file_v2.txt',header = T, row.names = 1)
group_sorted$oldName <- rownames(group_sorted)
rownames(group_sorted) <- group_sorted$newName

n <- which(group_sorted[["Group"]]=="TexTerm")
# identification
tfs <- lapply(unique(group_sorted$Group),
            function(x) {
             pr <- Data[!(row.names(Data) %in% housekeeping),]
             n <- which(group_sorted[["Group"]]==x)
             x <- unpairedtTest(pr,n,p=0.05,d=0.5)
             rownames(x)
            }) 
names(tfs) <- unique(group_sorted$Group)
```

## heatmap of cell state-specific TFs

From top to bottom, they're Naive, MP, TE, TCM, TEM, TRM, TexProg, TexInt, and TexTerm.

```{r, fig.width=10, fig.height=7}
ps <- lapply(names(tfs), function(x) {
  annotation_row <- data.frame("subsets"=rep(x,length(tfs[[x]])))
  rownames(annotation_row) <- tfs[[x]]
  get_heatmap(df=Data_normed_3[rownames(annotation_row),], cluster_rows=F, annotation_row=annotation_row, size = 5) 
})
```

# identify multi-taskers and single-taskers

Multi-taskers are TFs appearing in multiple cell states. Single-taskers are TFs only identified in single cell state.

```{r}
getRowAnnotation <- function(TFs){
  tmp <- unlist(TFs)
  redundants <- unname(tmp[duplicated(tmp)])
  uniques <- unname(tmp[!duplicated(tmp)])
  tmp2 <- tibble("subsets" = "MultiTasker","TFs"=unique(redundants))
  annotation_row <- tibble("subsets" = unlist(lapply(1:length(TFs), function(x) {rep(names(TFs[x]), length(TFs[[x]]))})),
                           "TFs" = unlist(TFs)) %>% 
    filter(TFs %in% setdiff(uniques, redundants)) %>%
    bind_rows(tmp2) %>%
    tibble::column_to_rownames("TFs")
  return(annotation_row)
  
}
annotation_row <- getRowAnnotation(tfs)

breaksList = seq(-2, 2, by = 0.1)
annotation_row %>% filter(subsets=="MultiTasker") %>% rownames() %>% writeLines('MultiTasker_TFs.txt')
annotation_row %>% filter(subsets!="MultiTasker") %>% rownames() %>% writeLines('SingleTasker_TFs.txt')
```

## heatmap of multi-taskers and single-taskers

First, we plot the heatmap for all multi-taskers:

```{r, fig.width=8, fig.height=12}
df_multi <- Data_normed_3[readLines('MultiTasker_TFs.txt'),]
p1 <- get_heatmap(df_multi, size=5)
```


Then, we group the multi-taskers into five groups as shown in main figure:

1.  shared in T cell states from acute infection
2.  shared in T cell states from chronic infection
3.  TRM and TEXterm
4.  early cell states: MP, TE, TEXprog, and TEXeff
5.  stem cell like state: Naive, memory, and TEXprog


### detailed grouping of multi-taskers

## heatmap of single-taskers

Heatmap for single-taskers:

```{r, fig.width=8, fig.height=12}
df_sgl <- Data_normed_3[readLines('SingleTasker_TFs.txt'),]
p1 <- get_heatmap(df_sgl, size=5)
```

# identification of TRM-specific and TEXterm-specific TFs

As described in Extended Data Fig.3a, we first curated a candiate list including TFs in TexTerm and TRM-TFs identified in cell-state-specific step. Then we performed unpaired t-test. The target group is TexTerm/TRM while the background is TRM/TexTerm.

```{r}
# manually select background samples
group2 <- group_sorted[grepl("TRM|TexTerm",group_sorted$Group),]
candidates <- union(tfs[['TexTerm']], tfs[['TRM']])
tfs2 <- lapply(unique(group2$Group),
            function(x) {
             pr <- Data[candidates,rownames(group2)]
             n <- which(group2[["Group"]]==x)
             x <- unpairedtTest(pr,n,p=0.05,d=0.5)
             rownames(x)
            })
names(tfs2) <- unique(group2$Group)
common_tfs <- setdiff(candidates, unlist(tfs2))
```

## bubble visualization for TRM and TEXterm TFs

```{r}
## import rna-seq data
rna_seq <- read.csv('rna_expr_TFs.csv', row.names = 1)
```

TFs that most active in TEXterm

```{r, fig.width=4, fig.height=8}
plot(bubble(tfs2[['TexTerm']],
            log2(rna_seq+1)[tfs2[['TexTerm']],rownames(group2)],
            Data_normed_3[tfs2[['TexTerm']],rownames(group2)]
))
```

TFs that most active in TRM

```{r, fig.width=4, fig.height=5}
plot(bubble(tfs2[['TRM']],
            log2(rna_seq+1)[tfs2[['TRM']],rownames(group2)],
            Data_normed_3[tfs2[['TRM']],rownames(group2)]
))
```

TFs that active in TRM and TEXterm

```{r, fig.width=4, fig.height=7}
plot(bubble(common_tfs,
            log2(rna_seq+1)[common_tfs,rownames(group2)],
            Data_normed_3[common_tfs,rownames(group2)]
))
```

# session info

```{r }
sessionInfo()
```
